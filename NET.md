# 네트워크

<details>
<summary>브라우저 주소창에 000.com을 입력하면 나오는 일</summary>
<div>

어느정도 깊이로 대답할지는 고민하셔야 합니다.

여기서는 가장 일반적인 "대학교"에서 배웠던 수준으로 서술했습니다.(dhcp, arp, dns, tcp, http)

<details>
<summary>DHCP</summary>
<div>

먼저 자신이 사용할 수 있는 ip주소를 얻어야 합니다, 이때 자신의 mac주소는 이미 알고있습니다.(mac주소는 하드웨어에 박혀있습니다)

DHCP는 요청(discover), 제공(offer), 진짜 사용해도 되는지 확인(request), 확인(ack) 단계로 진행됩니다.

DHCP 클라이언트는 브로드캐스트하게 요청 패킷을 뿌립니다.(DHCP는 응용계층 그러니까 맨 위 계층 프로토콜입니다)

하위 프로토콜로는 UDP로 전송하는데, 연결성을 보장할 필요가 없기 때문입니다.

그 이유는 애초에 DHCP 요청 패킷을 받은 머신은 자신이 DHCP 서버가 아니면 drop하기 때문이구요.

자신이 DHCP 서버(보통은 라우터입니다)라면 offer 패킷을 전송합니다.(이렇게 DHCP 서버는 클라이언트의 mac주소와 ip주소를 알게됩니다)

offer 패킷에는 dns의 ip, 서브넷 마스크, 해당 ip의 사용가능 기간(임대하기 때문입니다. DHCP는 애초에 동적 할당!) 등이 적혀있습니다.

이 과정에서 DHCP서버는 보통 라우터이니 first hop 라우터의 ip 주소도 알게 됩니다



</div>
</details>

<details>
<summary>ARP</summary>
<div>

이제 first hop 라우터의 mac 주소를 얻어와야 합니다.(arp는 인터넷 계층입니다. 맨아래보다 하나 위)

클라이언트는 브로드캐스트하게 arp 요청 패킷을 뿌립니다.

요청 패킷을 받은 머신을 패킷을 한번 깝니다. 그리고 적혀있는 ip 주소가 자신과 다르면 drop하고 같으면 reply합니다.

이렇게 알아온 mac 주소는 first hop router의 주소입니다.

그러니까 이 주소는 hop을 뛰면 바뀝니다.

</div>
</details>

<details>
<summary>DNS</summary>
<div>

주소창에 입력했던 주소에 해당하는 ip 주소를 얻어와야 합니다.(DNS는 어플리케이션 계층, 맨 위)

먼저 로컬 DNS에서 ip 주소가 있는지 찾고 없으면 외부 DNS 서버에 질의를 보냅니다.(이건 DHCP에서 얻어왔던 주소입니다.)

DNS는 계층적인 구조로 구성되어 있습니다. 루트에서부터 아래로 요청을 내리면서 ip 주소를 찾습니다.

000.com 이라 하면 . -> com. -> com.000 이런식으로 점점 내려갑니다.

</div>
</details>

<details>
<summary>TCP</summary>
<div>

DNS에서 얻어온 ip 주소에 해당하는 머신과 tcp 통신을 시작합니다.(전송계층, 위에서 2번째)

연결은 먼저 3-way hand shaking을 통해 수립됩니다.

syn-ack/syn-ack 이런 과정을 통해 연결이 수립되고, 이때 MSS와 윈도우 사이즈, isn을 정하게 됩니다.

MSS : 세그먼트 최대 사이즈입니다. 이때 세그먼트란 TCP 페이로드(데이터)의 크기입니다.

window size : tcp 패킷을 2개 보내면 2, 4개씩 보내면 4 이런식입니다. 이는 슬라이딩 윈도우 방식(흐름제어)으로 전송되기 때문에 설정합니다.

isn : 처음으로 쓰게될 시퀀스넘버(seq)입니다. 랜덤하게 생성됩니다.

연결이 수립되고 나면 패킷을 보내고 ack를 받는 과정으로 데이터를 전송합니다.

slow start라는 방식(혼잡제어)으로 시작하는데 아주 작은 윈도우 사이즈에서 시작해서 지수적으로 빠르게 증가시킵니다.

이러다 타임아웃에 의한 패킷 loss가 감지되면 윈도우 사이즈를 초기화 합니다.

다만 같은 ack 넘버가 3번 수신되게 되면, 타임아웃보다는 긍정적인 신호로 해석하고 fast-retransmit(오류제어)을 하게 됩니다.

연결 종료는 4-way hand shaking을 통해 합니다.

fin-ack-fin-ack 이런식으로 진행됩니다.

</div>
</details>

</div>
</details>
<hr>
<details>
<summary>HTTP와 HTTPS</summary>

<div>

기본적인 HTTP와 버전별 차이 그리고 ssl 핸드쉐이킹, 대칭키와 비대칭키 통신에 대해 설명합니다.

<details>
<summary>HTTP</summary>

<div>

### HTTP란
HTTP는 어플리케이션 계층 프로토콜입니다.

특징은 무상태, 비연결성입니다. 데이터 한번 전송하고 연결을 끊습니다.

GET, POST, PUS, DELETE, PATCH 등의 메소드가 있습니다.(이는 일종의 CRUD)

여기 헤더에 쿠키가 담겨있습니다.

참고로 쿠키는 도메인 단위로 구분됩니. a.com != b.com, a.com == mail.a.com(포트 달라도 도메인 같으면 공유가 됩니다!!)

### 버전별 차이

HTTP 1.1부터 keep-alive가 적용되었습니다.

매번 tcp부터 시작하는게 아니라 한번 열어둔 커넥션으로 하나 전송, 다음꺼 전송... 이렇게 진행합니다.

2부터는 멀티 플렉싱을 지원합니다. 하나의 커넥션 여러 파일을 쪼개서 싹 섞어서 보냅니다.

2에서는 서버 푸시도 지원합니다. html에 포함된 css, 이미지 등의 파일을 클라이언트 요청 없이 서버가 바로 전송합니다.

</div>

</details>

<details>
<summary>HTTPS</summary>
<div>

### 대칭키와 비대칭키

대칭키 : 서로 같은 키를 통해 의사소통하는 방식입니다. e.g. 문자열에 송신자는 3을 더하고, 수신자는 3을 빼기

비대칭키 : 서로 다른 키를 통해 의사소통하는 방식입니다. e.g. 문자열에 송신자가 공개키로 암호화, 수신자는 개인키로 복호화

HTTPS는 처음에는 비대칭키로 대칭키를 교환, 이후 통신에는 대칭키로 통신

### ssl/tls hand shaking

처음에는 클라이언트가 서버와 통신을 하고 싶은데 아직 신뢰를 하지 못합니다.

그래서 먼저 랜덤하게 생성된 값을 서버에 전송합니다.(A := 클라이언트가 생성한 랜덤한 값)

이를 수신한 서버는 랜덤하게 생성된 값(B := 서버가 생성한 랜덤한 값)과 서버의 인증서를 클라이언트에게 전송합니다.(이 인증서 중에는 **서버의 공개키**가 담겨있습니다.)

클라이언트는 이 인증서가 진짜인지 CA의 키로 복호화해 살펴봅니다.(이때 사용하는 키는 비대칭키입니다)

즉 서버는 CA의 개인키로 암호화된 정보를 클라이언트에게 전송하고, 클라이언트는 CA의 공개키를 통해 이를 복호화합니다.

이제 클라이언트는 서버를 신뢰할 수 있게 됩니다.

아까 주고 받았던 A와 B를 합쳐 대칭키를 만들고, 이 대칭키를 서버가 전송한 공개키로 암호화합니다.(대칭키는 탈취되면 안되기 때문입니다),

전부 비대칭키를 이용하여 통신하는 것은 오버헤드가 크기 때문에 이런 방식으로 효율적인 통신을 하게 됩니다.

</div>
</details>

</div>
</details>
<hr>
<details>
<summary>쿠키, 세션, 토큰</summary>

<div>
쿠키 : http 헤더에 담겨서 전달됩니다. 진짜 주는거라 클라이언트가 브라우저 쿠키를 삭제 안하면 남아있습니다.

세션 : 쿠키에 세션아이디를 넘겨주고, 서버는 이 아이디를 이용해 메모리, 디비, 파일 등에 상태를 저장합니다.

jwt토큰 : 유저에게 그냥 정보를 담아 넘겨줍니다. (X.Y.Z 이런 형태 헤더, 페이로드, 시그니쳐)

헤더, 페이로드, 서버의 비밀값을 헤더에 적혀있는 알고리즘으로 암호화하면 시그니처가 나옵니다.

보통 로그인시 토큰을 2개를 주어 토큰 방식의 단점을 보완합니다.(접근 토큰, 리프레시 토큰)

접근 토큰은 만료기한이 짧고 인가시에 사용됩니다.

접근토큰이 만료되면 리프레시 토큰으로 재발급 받는다.

</div>

</details>
