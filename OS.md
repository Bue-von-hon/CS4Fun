# 운영체제

<details>
<summary>프로세스와 쓰레드의 차이</summary>
<div>
### cpu 관점

쓰레드간 스위칭시 스택 영역만 비워주면 되서 스위칭 비용이 상대적으로 저렴합니다.(캐시 메모리를 비우지 않습니다)

프로세스간에는 스위칭 시 전체 영역을 바꿔주어야합니다. 오버헤드가 큽니다.

### 메모리 관점
스레드 사이에는 스택을 제외한 영역이 공유되고 있습니다.

따라서 쓰레드간 통신은 해당 영역을 통해 이루어 집니다.(쉽다)

프로세스간에는 서로 공유되는 영역이 없습니다.

프로세스 간의 통신에는 IPC라는 특별한 방법이 필요합니다.

IPC에는 공유 메모리, 파이프, 소켓 등의 방법이 있습니다.

공유 메모리 : 할당된 가상 메모리의 주소를 따라가면 두 프로세스가 서로 같은 물리 메모리 공간을 가르키고있는 방식입니다.

파이프 : 한 프로세스는 어떤 파일에 쓰기만하고, 다른 프로세스는 해당 파일을 읽기만 하면 단방향 파이프입니다. 이런게 2개 있으면 양방향이 됩니다.

소켓 : 소켓을 통해 프로세스간에 통신하는 방법입니다. 각 프로세스는 포트 번호로 구분됩니다.

127.0.0.1 이런식으로 ip 주소를 설정하고 통신하게 되는데 루프백을 ip 레이어에서 처리하기 때문에 오버헤드가 조금 있습니다.  

</div>
</details>

<details>
<summary>세마포어와 뮤텍스</summary>
<div>
뮤텍스 :  하나의 자원에 하나만 접근 가능합니다(이진 세마포어라고도 합니다)

세마포어 : 하나의 자원에 k개의 접근을 허용합니다

이 둘은 적용 대상에 차이가 있을 수 있습니다.

리눅스에서는 세마포어는 파일로, 뮤텍스는 변수로 구현되기에 각각 프로세스, 쓰레드에 적용됩니다.

단, 결국 이 둘은 원리적인 내용이라 구현 방식은 충분히 달라질 수 있습니다.

</div>
</details>

<details>
<summary>메모리</summary>
<div>

### 가상 메모리
실제 메모리의 물리주소 대신 가상 주소를 할당하여 사용하는 방식입니다.

이를 통해 더 큰 메모리 공간을 사용할 수 있게 됩니다.(가상 주소는 프로세스마다 독립적으로 할당되어 **서로 침범 못하게만들어 줍니다**)

가상 주소를 실제로 바인딩하는 타이밍은 3가지로 컴파일, 로드, 런타임(mmu라는 별도의 HW 필요)이 있습니다.

### 메모리 관리 기법

연속 할당 : 고정(메모리 공간을 미리 특정 크기로 나눔), 가변(메모리를 프로세스 단위로 짜름)

가변할당시에는 외부 단편화 문제가 발생합니다. 작은 프로세스 여러개를 할당하고 빼면 메모리에는 작은 hole이 우후죽순으로 생기는데요

이런 공간들을 모으면(컴팩션) 할당 할 수 있는 프로세스가 있지만 실제로는 그렇지 못한 문제입니다.

따라서 프로세스를 어떤 hole에 넣을지 3가지 방식이 있습니다.(first, best, worst)

불연속 할당 : 페이징(프로세스를 특정 크기로 짜름), 세그멘테이션(프로세스를 코드, 스택, 힙 등의 단위로 짜름), 페이지드 세그멘테이션(세그멘테이션을 페이지 단위로 짜름)

### 페이징

프로세스마다 페이지 테이블을 들고 있다.(컨텍스트 스위칭시 이것도 바꿈)

디멘드 페이징 : 요구된 페이지만 메모리에 올리는 기법, 페이지를 페이지 테이블에서 찾고, 없으면 운영체제에게 가져다 달라고 요구(이때 트랩)

(보통 프로그램의 특정 영영이 유독 많이 사용됩니다 -> 지역성, 디멘드 페이징은 지역성을 잘 활용합니다)

스토리지에서 페이지 가져와서 물리 메모리에 올리고 페이지 테이블에 기록

페이지 교체 : FIFO, LRU, LFU 등이 있습니다.

페이지 교체는 운영체제 개입이 없이 이루어집니다.(페이지 폴트가 발생해야 운영체제 개입)

따라서 FIFO, LRU, LFU 이런 친구들은 구현이 어렵습니다.

대신 clock 알고리즘을 이용합니다.

참조된 페이지를 원형으로 쭉 이어둡니다. 시작부터 끝까지 돌면서 참조 비트를 1은 0으로 0은 교체시킵니다.

이 단순한 방식은 LRU와 비슷한 시간복잡도를 갖는다고 알려져있습니다.(강의내용...)

</div>
</details>